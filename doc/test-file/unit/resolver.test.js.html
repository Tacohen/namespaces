<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">unit/resolver.test.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/ziflex/namespaces.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/container.js~Container.html">Container</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/module.js~Module.html">Module</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/namespace.js~Namespace.html">Namespace</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/resolver.js~Resolver.html">Resolver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/storage.js~Storage.html">Storage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createPathMap">createPathMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-create">create</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-forEach">forEach</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isArray">isArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isFunction">isFunction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNull">isNull</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNullOrUndefined">isNullOrUndefined</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isObject">isObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isString">isString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isUndefined">isUndefined</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isValidName">isValidName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-joinPath">joinPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-map">map</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseArgs">parseArgs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-splitPath">splitPath</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">unit/resolver.test.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint-disable no-unused-expressions, func-names  */

import { expect } from &apos;chai&apos;;
import Container from &apos;../../src/container&apos;;

describe(&apos;Resolver&apos;, function() {
    let container = null;

    beforeEach(function() {
        container = new Container();
    });

    describe(&apos;.resolve&apos;, () =&gt; {
        context(&apos;empty container&apos;, () =&gt; {
            it(&apos;should throw error&apos;, () =&gt; {
                const resolve = () =&gt; {
                    container.resolve(&apos;foo&apos;);
                };

                expect(resolve).to.throw();
            });
        });

        describe(&apos;#const&apos;, () =&gt; {
            context(&apos;plain types&apos;, () =&gt; {
                it(&apos;should successfully resolve function&apos;, () =&gt; {
                    const module = function foo() { return &apos;bar&apos;; };
                    container.const(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                    expect(found).to.eql(found2);
                    expect(found() === &apos;bar&apos;).to.be.true;
                });

                it(&apos;should successfully resolve object&apos;, () =&gt; {
                    const module = { name: &apos;bar&apos; };
                    container.const(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });

                it(&apos;should successfully resolve number&apos;, () =&gt; {
                    const module = 10;
                    container.const(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });

                it(&apos;should successfully resolve string&apos;, () =&gt; {
                    const module = &apos;foo&apos;;
                    container.const(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });

                it(&apos;should successfully resolve array&apos;, () =&gt; {
                    const module = [1, 2, 3];
                    container.const(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });
            });
        });

        describe(&apos;#value&apos;, () =&gt; {
            context(&apos;plain types&apos;, () =&gt; {
                it(&apos;should successfully resolve object&apos;, () =&gt; {
                    const module = { name: &apos;bar&apos; };
                    container.value(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });

                it(&apos;should successfully resolve number&apos;, () =&gt; {
                    const module = 10;
                    container.value(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });

                it(&apos;should successfully resolve string&apos;, () =&gt; {
                    const module = &apos;foo&apos;;
                    container.value(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });

                it(&apos;should successfully resolve array&apos;, () =&gt; {
                    const module = [1, 2, 3];
                    container.value(&apos;value&apos;, module);
                    const found = container.resolve(&apos;value&apos;);
                    const found2 = container.resolve(&apos;value&apos;);
                    expect(found).to.equal(module);
                    expect(found2).to.equal(module);
                });
            });
            context(&apos;constructor&apos;, () =&gt; {
                context(&apos;without dependencies&apos;, () =&gt; {
                    it(&apos;should successfully resolved&apos;, () =&gt; {
                        let index = 0;
                        container.value(&apos;value&apos;, function User() {
                            index += 1;
                            this.name = `foo_${index}`;
                            this.surname = `bar_${index}`;
                        });

                        const found = container.resolve(&apos;value&apos;);
                        const found2 = container.resolve(&apos;value&apos;);
                        expect(found).to.exist;
                        expect(found2).to.exist;
                        expect(found).to.not.equal(found2);
                        expect(found.name).to.exist;
                        expect(found.surname).to.exist;
                    });
                });
                context(&apos;with dependencies&apos;, () =&gt; {
                    it(&apos;should successfully resolved&apos;, () =&gt; {
                        let index = 0;
                        container.value(&apos;group&apos;, function Group() {
                            this.accounts = [];
                        });
                        container.value(&apos;user&apos;, [&apos;group&apos;], function User(group) {
                            index += 1;
                            this.name = `foo_${index}`;
                            this.surname = `bar_${index}`;
                            this.group = group;
                        });

                        const found = container.resolve(&apos;user&apos;);
                        expect(found).to.exist;
                        expect(found.group).to.exist;
                        expect(found.group.accounts).to.exist;
                    });
                });
            });
        });

        describe(&apos;#service&apos;, () =&gt; {
            context(&apos;without dependencies&apos;, () =&gt; {
                it(&apos;should resolve single service&apos;, () =&gt; {
                    container.service(&apos;http&apos;, function HttpService() {
                        this.get = () =&gt; {};
                        this.post = () =&gt; {};
                    });

                    const found = container.resolve(&apos;http&apos;);
                    const found2 = container.resolve(&apos;http&apos;);

                    expect(found).to.exist;
                    expect(found).to.equal(found2);
                });
            });
            context(&apos;with dependencies&apos;, () =&gt; {
                it(&apos;should resolve single service&apos;, () =&gt; {
                    container.value(&apos;http-transport&apos;, function HttpTransport() {});

                    container.service(&apos;settings&apos;, function Settings() {});

                    container.service(&apos;http&apos;, [&apos;http-transport&apos;, &apos;settings&apos;], function HttpService(transport, settings) {
                        this.settings = settings;
                        this.transport = transport;
                        this.get = () =&gt; {};
                        this.post = () =&gt; {};
                    });

                    const found = container.resolve(&apos;http&apos;);
                    const found2 = container.resolve(&apos;http&apos;);

                    expect(found).to.exist;
                    expect(found).to.equal(found2);
                    expect(found.settings).to.exist;
                    expect(found.transport).to.exist;
                });
            });
        });

        describe(&apos;#factory&apos;, () =&gt; {
            context(&apos;without dependencies&apos;, () =&gt; {
                it(&apos;should resolve single service&apos;, () =&gt; {
                    container.factory(&apos;http&apos;, function HttpServiceFactory() {
                        return new function HttpService() {
                            this.get = () =&gt; {};
                            this.post = () =&gt; {};
                        };
                    });

                    const found = container.resolve(&apos;http&apos;);
                    const found2 = container.resolve(&apos;http&apos;);

                    expect(found).to.exist;
                    expect(found).to.equal(found2);
                });
            });
            context(&apos;with dependencies&apos;, () =&gt; {
                it(&apos;should resolve single service&apos;, () =&gt; {
                    container.value(&apos;http-transport&apos;, function HttpTransport() {});

                    container.service(&apos;settings&apos;, function Settings() {});

                    container.factory(&apos;http&apos;, [&apos;http-transport&apos;, &apos;settings&apos;], function HttpServiceFactory(transport, settings) {
                        return new function HttpService() {
                            this.settings = settings;
                            this.transport = transport;
                            this.get = () =&gt; {};
                            this.post = () =&gt; {};
                        };
                    });

                    const found = container.resolve(&apos;http&apos;);
                    const found2 = container.resolve(&apos;http&apos;);

                    expect(found).to.exist;
                    expect(found).to.equal(found2);
                    expect(found.settings).to.exist;
                    expect(found.transport).to.exist;
                });
            });
        });

        describe(&apos;in namespace&apos;, () =&gt; {
            describe(&apos;#value&apos;, () =&gt; {
                context(&apos;same name&apos;, () =&gt; {
                    it(&apos;should resolve from different namespaces&apos;, () =&gt; {
                        container.value(&apos;value&apos;, 1);
                        container.namespace(&apos;consts&apos;).value(&apos;value&apos;, 2);

                        expect(container.resolve(&apos;value&apos;)).to.equal(1);
                        expect(container.resolve(&apos;consts/value&apos;)).to.equal(2);
                    });
                });

                context(&apos;as dependency&apos;, () =&gt; {
                    it(&apos;should resolve&apos;, () =&gt; {
                        container.namespace(&apos;consts&apos;).value(&apos;value&apos;, 1);
                        container.namespace(&apos;models&apos;).value(&apos;user&apos;, [&apos;consts/value&apos;], function User(value) {
                            this.value = value;
                        });

                        const user = container.resolve(&apos;models/user&apos;);
                        expect(user).to.exist;
                        expect(user.value).to.equal(1);
                    });
                });
            });
            describe(&apos;#factory&apos;, () =&gt; {
                context(&apos;same name&apos;, () =&gt; {
                    it(&apos;should resolve from different namespaces&apos;, () =&gt; {
                        container.factory(&apos;service&apos;, function factoryA() {
                            return {name: &apos;A&apos;};
                        });
                        container.namespace(&apos;services&apos;).factory(&apos;service&apos;, function factoryB() {
                            return {name: &apos;B&apos;};
                        });

                        const serviceA = container.resolve(&apos;service&apos;);
                        const serviceB = container.resolve(&apos;services/service&apos;);
                        expect(serviceA).to.exist;
                        expect(serviceB).to.exist;
                        expect(serviceA).to.not.equal(serviceB);
                    });
                });
                context(&apos;as dependency&apos;, () =&gt; {
                    it(&apos;should resolve&apos;, () =&gt; {
                        container.namespace(&apos;services/api&apos;).factory(&apos;service&apos;, function factoryA() {
                            return {name: &apos;A&apos;};
                        });
                        container.namespace(&apos;services&apos;).factory(&apos;service&apos;, [&apos;services/api/service&apos;], function factoryB(serviceA) {
                            return {name: &apos;B&apos;, api: serviceA};
                        });

                        const serviceB = container.resolve(&apos;services/service&apos;);
                        const serviceA = container.resolve(&apos;services/api/service&apos;);
                        expect(serviceA).to.exist;
                        expect(serviceB).to.exist;
                        expect(serviceB.api).to.equal(serviceA);
                    });
                });
            });
            describe(&apos;#service&apos;, () =&gt; {
                context(&apos;same name&apos;, () =&gt; {
                    it(&apos;should resolve from different namespaces&apos;, () =&gt; {
                        container.service(&apos;service&apos;, function ServiceA() {
                        });
                        container.namespace(&apos;services&apos;).service(&apos;service&apos;, function ServiceB() {
                        });

                        const serviceA = container.resolve(&apos;service&apos;);
                        const serviceB = container.resolve(&apos;services/service&apos;);
                        expect(serviceA).to.exist;
                        expect(serviceB).to.exist;
                        expect(serviceA).to.not.equal(serviceB);
                    });
                });
                context(&apos;as dependency&apos;, () =&gt; {
                    it(&apos;should resolve&apos;, () =&gt; {
                        container.namespace(&apos;services/api&apos;).service(&apos;service&apos;, function ServiceA() {});
                        container.namespace(&apos;services&apos;).service(&apos;service&apos;, [&apos;services/api/service&apos;], function ServiceB(serviceA) {
                            this.api = serviceA;
                        });

                        const serviceB = container.resolve(&apos;services/service&apos;);
                        const serviceA = container.resolve(&apos;services/api/service&apos;);
                        expect(serviceA).to.exist;
                        expect(serviceB).to.exist;
                        expect(serviceB.api).to.equal(serviceA);
                    });
                });
            });
        });

        // describe(&apos;circular dependency&apos;, () =&gt; {
        //    it(&apos;should throw during resolving&apos;, () =&gt; {
        //        const self = () =&gt; {
        //            container.register().value(&apos;value1&apos;, [&apos;value1&apos;], 1);
        //            container.resolve(&apos;value1&apos;);
        //        };
        //        const shallow = () =&gt; {
        //            container.register().value(&apos;value1&apos;, [&apos;value2&apos;], 1);
        //            container.register().value(&apos;value2&apos;, [&apos;value1&apos;], 2);
        //            container.resolve(&apos;value1&apos;);
        //            container.resolve(&apos;value2&apos;);
        //        };
        //        const deep = () =&gt; {
        //            container.register().value(&apos;a&apos;, [&apos;b&apos;, &apos;d&apos;], &apos;a&apos;);
        //            container.register().value(&apos;b&apos;, [&apos;c&apos;, &apos;e&apos;], &apos;b&apos;);
        //            container.register().value(&apos;c&apos;, [&apos;e&apos;, &apos;d&apos;], &apos;c&apos;);
        //            container.register().value(&apos;d&apos;, [&apos;b&apos;], &apos;d&apos;);
        //            container.register().value(&apos;e&apos;, &apos;e&apos;);
        //
        //            container.resolve(&apos;a&apos;);
        //        };
        //
        //        expect(self).to.throw(ReferenceError);
        //        expect(shallow).to.throw(ReferenceError);
        //        expect(deep).to.throw(ReferenceError);
        //    });
        // });
    });
    describe(&apos;.resolveAll&apos;, () =&gt; {
        context(&apos;empty container&apos;, () =&gt; {
            it(&apos;should throw error&apos;, () =&gt; {
                expect(() =&gt; {
                    container.resolveAll(&apos;foo&apos;);
                }).to.throw();
            });
        });

        context(&apos;not empty container&apos;, () =&gt; {
            it(&apos;should resolve all modules from particular namespace&apos;, () =&gt; {
                const foo = container.namespace(&apos;foo&apos;);
                foo.service(&apos;A&apos;, function() { this.name = &apos;A&apos;; });
                foo.service(&apos;B&apos;, [&apos;foo/A&apos;], function() { this.name = &apos;B&apos;; });
                foo.service(&apos;C&apos;, [&apos;foo/B&apos;], function() { this.name = &apos;C&apos;; });
                foo.service(&apos;D&apos;, [&apos;foo/B&apos;, &apos;foo/C&apos;], function() { this.name = &apos;D&apos;; });

                const bar = container.namespace(&apos;bar&apos;);
                bar.service(&apos;E&apos;, [&apos;foo/A&apos;], function() { this.name = &apos;E&apos;; });
                bar.service(&apos;F&apos;, [&apos;bar/E&apos;, &apos;foo/C&apos;], function() { this.name = &apos;F&apos;; });

                const resolved = container.resolveAll(&apos;bar&apos;);
                const arr = [];

                for (const name in resolved) {
                    if (resolved.hasOwnProperty(name)) {
                        arr.push({
                            name: name,
                            value: resolved[name]
                        });
                    }
                }

                expect(arr.length).to.equal(2);
            });
        });
    });
});

/* eslint-enable no-unused-expressions, func-names  */
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.5)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
